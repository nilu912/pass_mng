{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-cc509e3ac22df467e381fa669522278de18a207a",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/PassMang.sol": "project/contracts/PassMang.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/PassMang.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.23;\r\n\r\ncontract PassMang {\r\n    struct User {\r\n        bytes32 masterPasswordHash;\r\n        bytes32 salt;\r\n        uint timestamp;\r\n        bool isActive;\r\n        uint totalEntries;\r\n    }\r\n    \r\n    struct PasswordEntry {\r\n        uint id;\r\n        bytes32 uniqueHash;\r\n        string webUrl;\r\n        string userName;\r\n        string password;\r\n        uint timestamp;\r\n        bool isActive;\r\n    }\r\n\r\n    mapping(address => User) public users;\r\n    mapping(address => bool) public registeredUser;\r\n    mapping(address => PasswordEntry[]) public passwordEntries;\r\n    mapping(bytes32 => bool) public uniqueHashExists;\r\n\r\n    event userRegisteredEvent(\r\n        address user,\r\n        bytes32 hashedPass,\r\n        bytes32 salt,\r\n        uint timestamp\r\n    );\r\n    \r\n    event passwordAddedEvent(\r\n        address user,\r\n        bytes32 uniqueHash,\r\n        string webUrl,\r\n        string userName,\r\n        string password,\r\n        uint timestamp\r\n    );\r\n    \r\n    event passwordUpdatedEvent(\r\n        address user,\r\n        uint id,\r\n        bytes32 oldHash,\r\n        bytes32 newHash,\r\n        string webUrl,\r\n        uint timestamp\r\n    );\r\n    \r\n    event passwordDeletedEvent(\r\n        address user,\r\n        uint id,\r\n        bytes32 uniqueHash,\r\n        uint timestamp\r\n    );\r\n\r\n    modifier isUserReg() {\r\n        require(isUserRegister(), \"User not registered!\");\r\n        _;\r\n    }\r\n\r\n    function generatePassword(\r\n        string memory _password\r\n    ) internal view returns (bytes32 _masterPass, bytes32 _salt) {\r\n        bytes32 salt = keccak256(abi.encodePacked(msg.sender, block.timestamp));\r\n        bytes32 masterPass = keccak256(abi.encodePacked(_password, salt));\r\n        return (masterPass, salt);\r\n    }\r\n    \r\n    function generateHash(\r\n        bytes memory _input\r\n    ) internal pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(_input));\r\n    }\r\n    \r\n    function registerUser(string memory _masterPassword) public {\r\n        require(!registeredUser[msg.sender], \"User already registered!\");\r\n        (bytes32 masterPass, bytes32 salt) = generatePassword(_masterPassword);\r\n        users[msg.sender] = User({\r\n            masterPasswordHash: masterPass,\r\n            salt: salt,\r\n            timestamp: block.timestamp,\r\n            isActive: true,\r\n            totalEntries: 0\r\n        });\r\n        registeredUser[msg.sender] = true;\r\n        emit userRegisteredEvent(msg.sender, masterPass, salt, block.timestamp);\r\n    }\r\n\r\n    function isUserRegister() public view returns (bool) {\r\n        return registeredUser[msg.sender];\r\n    }\r\n\r\n    function addPasswordEntry(\r\n        string memory _webUrl,\r\n        string memory _userName,\r\n        string memory _password\r\n    ) public isUserReg {\r\n        bytes32 uniqueHash = keccak256(abi.encodePacked(_webUrl, _userName, msg.sender));\r\n        require(!uniqueHashExists[uniqueHash], \"Entry already exists!\");\r\n        \r\n        users[msg.sender].totalEntries++;\r\n        uniqueHashExists[uniqueHash] = true;\r\n        \r\n        passwordEntries[msg.sender].push(\r\n            PasswordEntry({\r\n                id: users[msg.sender].totalEntries,\r\n                uniqueHash: uniqueHash,\r\n                webUrl: _webUrl,\r\n                userName: _userName,\r\n                password: _password,\r\n                timestamp: block.timestamp,\r\n                isActive: true\r\n            })\r\n        );\r\n        \r\n        emit passwordAddedEvent(\r\n            msg.sender,\r\n            uniqueHash,\r\n            _webUrl,\r\n            _userName,\r\n            _password,\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n    function getUsersAllEntries() public view isUserReg returns(PasswordEntry[] memory){\r\n        return passwordEntries[msg.sender]; \r\n    }\r\n    \r\n    function getPasswordEntry(uint _id) public view isUserReg returns(PasswordEntry memory){\r\n        require(_id > 0 && _id <= users[msg.sender].totalEntries, \"Invalid ID!\");\r\n        return passwordEntries[msg.sender][_id - 1];\r\n    }\r\n    \r\n    function getUserInfo() public view returns(User memory){\r\n        return users[msg.sender];\r\n    }\r\n    \r\n    // FIXED: Update password entry with proper ID handling and uniqueHash update\r\n    function updatePasswordEntry(\r\n        uint256 _id,\r\n        string memory _webUrl,\r\n        string memory _userName,\r\n        string memory _password\r\n    ) public isUserReg {\r\n        require(_id > 0 && _id <= users[msg.sender].totalEntries, \"Invalid entry ID\");\r\n        \r\n        uint256 index = _id - 1; // Convert ID to array index\r\n        PasswordEntry storage entry = passwordEntries[msg.sender][index];\r\n        \r\n        require(entry.isActive, \"Entry is not active\");\r\n        \r\n        // Generate new uniqueHash\r\n        bytes32 newUniqueHash = keccak256(abi.encodePacked(_webUrl, _userName, msg.sender));\r\n        \r\n        // If the hash changed, check if new hash already exists\r\n        if (newUniqueHash != entry.uniqueHash) {\r\n            require(!uniqueHashExists[newUniqueHash], \"Entry with these credentials already exists!\");\r\n            \r\n            // Remove old hash and add new hash\r\n            uniqueHashExists[entry.uniqueHash] = false;\r\n            uniqueHashExists[newUniqueHash] = true;\r\n        }\r\n        \r\n        // Store old hash for event\r\n        bytes32 oldHash = entry.uniqueHash;\r\n        \r\n        // Update entry\r\n        entry.uniqueHash = newUniqueHash;\r\n        entry.webUrl = _webUrl;\r\n        entry.userName = _userName;\r\n        entry.password = _password;\r\n        entry.timestamp = block.timestamp;\r\n        \r\n        emit passwordUpdatedEvent(\r\n            msg.sender,\r\n            _id,\r\n            oldHash,\r\n            newUniqueHash,\r\n            _webUrl,\r\n            block.timestamp\r\n        );\r\n    }\r\n    \r\n    // ADDED: Delete password entry (soft delete)\r\n    function deletePasswordEntry(uint256 _id) public isUserReg {\r\n        require(_id > 0 && _id <= users[msg.sender].totalEntries, \"Invalid entry ID\");\r\n        \r\n        uint256 index = _id - 1;\r\n        PasswordEntry storage entry = passwordEntries[msg.sender][index];\r\n        \r\n        require(entry.isActive, \"Entry is already deleted\");\r\n        \r\n        // Soft delete - mark as inactive\r\n        entry.isActive = false;\r\n        \r\n        // Remove from uniqueHash mapping\r\n        uniqueHashExists[entry.uniqueHash] = false;\r\n        \r\n        emit passwordDeletedEvent(\r\n            msg.sender,\r\n            _id,\r\n            entry.uniqueHash,\r\n            block.timestamp\r\n        );\r\n    }\r\n    \r\n    // ADDED: Hard delete (optional - permanently removes entry)\r\n    function permanentlyDeleteEntry(uint256 _id) public isUserReg {\r\n        require(_id > 0 && _id <= users[msg.sender].totalEntries, \"Invalid entry ID\");\r\n        \r\n        uint256 index = _id - 1;\r\n        PasswordEntry storage entry = passwordEntries[msg.sender][index];\r\n        \r\n        // Remove from uniqueHash mapping\r\n        uniqueHashExists[entry.uniqueHash] = false;\r\n        \r\n        // Get array length\r\n        uint256 lastIndex = passwordEntries[msg.sender].length - 1;\r\n        \r\n        // If not the last element, swap with last element\r\n        if (index != lastIndex) {\r\n            passwordEntries[msg.sender][index] = passwordEntries[msg.sender][lastIndex];\r\n        }\r\n        \r\n        // Remove last element\r\n        passwordEntries[msg.sender].pop();\r\n        \r\n        emit passwordDeletedEvent(\r\n            msg.sender,\r\n            _id,\r\n            entry.uniqueHash,\r\n            block.timestamp\r\n        );\r\n    }\r\n    \r\n    // ADDED: Reactivate a soft-deleted entry\r\n    function reactivateEntry(uint256 _id) public isUserReg {\r\n        require(_id > 0 && _id <= users[msg.sender].totalEntries, \"Invalid entry ID\");\r\n        \r\n        uint256 index = _id - 1;\r\n        PasswordEntry storage entry = passwordEntries[msg.sender][index];\r\n        \r\n        require(!entry.isActive, \"Entry is already active\");\r\n        \r\n        // Check if hash is available\r\n        require(!uniqueHashExists[entry.uniqueHash], \"Conflicting entry exists\");\r\n        \r\n        entry.isActive = true;\r\n        uniqueHashExists[entry.uniqueHash] = true;\r\n    }\r\n}\r\n\r\n\r\n// pragma solidity ^0.8.23;\r\n\r\n// contract PassMang {\r\n//     struct User {\r\n//         bytes32 masterPasswordHash;\r\n//         bytes32 salt;\r\n//         uint timestamp;\r\n//         bool isActive;\r\n//         uint totalEntries;\r\n//     }\r\n//     struct PasswordEntry {\r\n//         uint id;\r\n//         bytes32 uniqueHash;\r\n//         string webUrl;\r\n//         string userName;\r\n//         string password;\r\n//         uint timestamp;\r\n//         bool isActive;\r\n//     }\r\n\r\n//     mapping(address => User) public users;\r\n//     mapping(address => bool) public registeredUser;\r\n//     mapping(address => PasswordEntry[]) public passwordEntries;\r\n//     mapping(bytes32 => bool) public uniqueHashExists;\r\n\r\n//     event userRegisteredEvent(\r\n//         address user,\r\n//         bytes32 hashedPass,\r\n//         bytes32 salt,\r\n//         uint timestamp\r\n//     );\r\n//     event passwordAddedEvent(\r\n//         address user,\r\n//         bytes32 uniqueHash,\r\n//         string webUrl,\r\n//         string userName,\r\n//         string password,\r\n//         uint timestamp\r\n//     );\r\n\r\n//     modifier isUserReg() {\r\n//         require(isUserRegister(), \"User not registered!\");\r\n//         _;\r\n//     }\r\n\r\n//     function generatePassword(\r\n//         string memory _password\r\n//     ) internal view returns (bytes32 _masterPass, bytes32 _salt) {\r\n//         bytes32 salt = keccak256(abi.encodePacked(msg.sender, block.timestamp));\r\n//         bytes32 masterPass = keccak256(abi.encodePacked(_password, salt));\r\n//         return (masterPass, salt);\r\n//     }\r\n//     function generateHash(\r\n//         bytes memory _input\r\n//     ) internal pure returns (bytes32) {\r\n//         return keccak256(abi.encodePacked(_input));\r\n//     }\r\n//     function registerUser(string memory _masterPassword) public {\r\n//         require(!registeredUser[msg.sender], \"User already registered!\");\r\n//         (bytes32 masterPass, bytes32 salt) = generatePassword(_masterPassword);\r\n//         users[msg.sender] = User({\r\n//             masterPasswordHash: masterPass,\r\n//             salt: salt,\r\n//             timestamp: block.timestamp,\r\n//             isActive: true,\r\n//             totalEntries: 0\r\n//         });\r\n//         registeredUser[msg.sender] = true;\r\n//         emit userRegisteredEvent(msg.sender, masterPass, salt, block.timestamp);\r\n//     }\r\n\r\n//     function isUserRegister() public view returns (bool) {\r\n//         return registeredUser[msg.sender];\r\n//     }\r\n\r\n//     function addPasswordEntry(\r\n//         string memory _webUrl,\r\n//         // bytes memory _userName,\r\n//         // bytes memory _password\r\n//         string memory _userName,\r\n//         string memory _password\r\n//     ) public isUserReg {\r\n//         users[msg.sender].totalEntries++;\r\n//         bytes32 uniqueHash = keccak256(abi.encodePacked(_webUrl, _userName));\r\n//         require(!uniqueHashExists[uniqueHash], \"Entry already exists!\");\r\n//         uniqueHashExists[uniqueHash] = true;\r\n//         passwordEntries[msg.sender].push(\r\n//             PasswordEntry({\r\n//                 id: users[msg.sender].totalEntries,\r\n//                 uniqueHash: uniqueHash,\r\n//                 webUrl: _webUrl,\r\n//                 userName: _userName,\r\n//                 password: _password,\r\n//                 timestamp: block.timestamp,\r\n//                 isActive: true\r\n//             })\r\n//         );\r\n//         emit passwordAddedEvent(\r\n//             msg.sender,\r\n//             uniqueHash,\r\n//             _webUrl,\r\n//             _userName,\r\n//             _password,\r\n//             block.timestamp\r\n//         );\r\n//     }\r\n\r\n//     function getUsersAllEntries() public view isUserReg returns(PasswordEntry[] memory){\r\n//         return passwordEntries[msg.sender]; \r\n//     }\r\n//     function getPasswordEntry(uint _id) public view isUserReg returns(PasswordEntry memory){\r\n//         require(users[msg.sender].totalEntries >= _id, \"Id not found!\");\r\n//         return passwordEntries[msg.sender][_id-1];\r\n//     }\r\n//     function getUserInfo() public view returns(User memory){\r\n//         return users[msg.sender];\r\n//     }\r\n// }\r\n"
      }
    }
  }
}